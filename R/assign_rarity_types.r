#' Assign rarity types based on rarity restriction
#'
#' This function classifies species into discrete rarity types based on combinations rarity axes characterizing restrictions of the global model of discretized rarity. It uses k-means clustering or percentile-based thresholding to determine the rarity of each dimension of rarity (+ for rare and - for common).
#'
#' @param df A data frame containing species-level rarity dimensions. Must include one row per species and columns matching the axes listed in \code{thresholds} and/or \code{models_to_run}.
#' @param models_to_run A character vector of restrictions. Custom model names are parsed dynamically.
#' @param slope_factor A numeric value passed to \code{find_optimal_k()} for determining the optimal number of k clusters based on the steepness of the slope. Default is 1.
#' @param thresholds A named list of numeric values representing the percentile cutoff for each axis. Default thresholds mark the bottom 15% for geographic rarity and the top 10% for functional and phylogenetic rarity. Custom dimensions of rarity must be thresholded by user.
#' @param directions A named list specifying whether rarity is associated with \code{"low"} or \code{"high"} values for each dimension If unspecified, the function defaults to \code{"low"} for \code{"GR"} and \code{"GL"}, and \code{"high"} for all other axes. Users can specify only a subset of axes to override the defaults.
#'
#' @param k_means Logical; if \code{TRUE}, thresholds are computed using k-means clustering instead of percentile cutoffs. 
#'
#' @return
#' A data frame with species-level rarity classifications. This includes raw values and rarity flags for each axis and rarity classifications for each restriction. 
#'
#' @details
#' Thresholds can be derived either by percentile cutoffs or k-means clustering, controlled by \code{k_means}.  
#' K-means clustering is only applied if the axis has at least 5 non-NA values; otherwise, percentile cutoffs are used as fallback.  
#' Missing values (\code{NA}s) in axis data are ignored during threshold calculations. 
#' Composite rarity labels are generated by passing each species' axis flags through \code{map_est_types()}.
#'
#' @seealso \code{\link{map_est_types}}, \code{\link{find_optimal_k}}, \code{\link{rename_model_columns}}, \code{\link{check_eco_status}} for related classification utilities.
#'
#' @examples
#' \dontrun{
#' data <- data.frame(
#'   species = c("Species1", "Species2", "Species3"),
#'   GR = c(0.02, 0.6, 0.1),
#'   FR = c(0.95, 0.2, 0.91),
#'   PR = c(0.92, 0.3, 0.85)
#' )
#' 
#' classified <- assign_rarity_types(
#'   df = data,
#'   models_to_run = c("GRFR", "EER"),
#'   slope_factor = 1,
#'   k_means = FALSE,
#'   thresholds = list(GR = 0.15, GL = 0.15,
#'                                  FR = 0.75, FL = 0.9,
#'                                  PR = 0.90, PL = 0.90),
#'   directions = list(PR = "low")
#' )
#' print(classified)
#' }
#'
#' @author Alivia G. Nytko, \email{anytko@@vols.utk.edu}
#' @export
assign_rarity_types <- function(df, models_to_run, slope_factor = 1,
                                thresholds = list(
                                  GR = 0.15, GL = 0.15,
                                  FR = 0.9, FL = 0.9,
                                  PR = 0.90, PL = 0.90
                                ),
                                directions = list(
                                  GR = "low", GL = "low",
                                  FR = "high", FL = "high",
                                  PR = "high", PL = "high"
                                ),
                                k_means = FALSE) {

  requested_axes <- unique(unlist(strsplit(paste(models_to_run, collapse = ""), "")))
  standard_axes <- c("GR", "GL", "FR", "FL", "PR", "PL")
  requested_axes <- unique(unlist(
    regmatches(models_to_run, gregexpr(paste(standard_axes, collapse = "|"), models_to_run))
  ))

    missing_axes <- setdiff(requested_axes, colnames(df))
    if (length(missing_axes) > 0) {
      warning("The following axes are missing from the input data frame: ",
              paste(missing_axes, collapse = ", "),
              ". Missing axes will be marked with '?' in output classifications.")
    }

  all_axes <- intersect(names(thresholds), colnames(df))

  for (axis in all_axes) {
    df[[paste0(axis, "_raw")]] <- df[[axis]]
  }

  find_kmeans_threshold <- function(df, axis, thresholds, get_smallest_cluster = TRUE, slope_factor) {
    data_vec <- na.omit(df[[axis]])

    if (length(data_vec) < 5) {
      warning(paste("Too few data points for k-means in", axis, "- falling back to quantile."))
      return(quantile(data_vec, probs = thresholds[[axis]], na.rm = TRUE))
    }

    k <- tryCatch({
      find_optimal_k(df, axis, slope_factor = slope_factor)$optimal_k
    }, error = function(e) NA)

    if (is.na(k) || k < 2 || k >= length(data_vec)) {
      warning(paste("Invalid or unusable k for", axis, "- falling back to quantile."))
      return(quantile(data_vec, probs = thresholds[[axis]], na.rm = TRUE))
    }

    result <- tryCatch({
      km <- kmeans(data_vec, centers = k)
      means <- tapply(data_vec, km$cluster, mean)
      target_cluster <- if (get_smallest_cluster) which.min(means) else which.max(means)
      if (get_smallest_cluster) {
        max(data_vec[km$cluster == target_cluster], na.rm = TRUE)
      } else {
        min(data_vec[km$cluster == target_cluster], na.rm = TRUE)
      }
    }, error = function(e) {
      warning(paste("K-means failed for", axis, "-", e$message, "- falling back to quantile."))
      return(quantile(data_vec, probs = thresholds[[axis]], na.rm = TRUE))
    })

    return(result)
  }

  for (axis in all_axes) {
    direction <- directions[[axis]]
    if (is.null(direction)) {
      # Smart default: GR and GL → "low", everything else → "high"
      direction <- if (axis %in% c("GR", "GL")) "low" else "high"
      message(paste("Direction for axis", axis, "not provided. Defaulting to", shQuote(direction), "."))
    }

    threshold_val <- if (!k_means) {
      quantile(df[[axis]], probs = thresholds[[axis]], na.rm = TRUE)
    } else {
      get_smallest_cluster <- direction == "low"
      find_kmeans_threshold(df, axis, thresholds, get_smallest_cluster = get_smallest_cluster, slope_factor = slope_factor)
    }

    # Use direction to determine flag logic
    df[[paste0(axis, "_flag")]] <- ifelse(
      (direction == "low" & df[[axis]] <= threshold_val) |
      (direction == "high" & df[[axis]] >= threshold_val),
      "+", "-"
    )
  }

  extract_model_axes <- function(models) {
    standard_axes <- c("GR", "GL", "FR", "FL", "PR", "PL")
    unique(unlist(
      lapply(models, function(m) {
        matches <- unlist(regmatches(m, gregexpr(paste(standard_axes, collapse = "|"), m)))
        unmatched <- m
        for (ax in matches) {
          unmatched <- sub(ax, "", unmatched, fixed = TRUE)
        }
        extras <- unlist(strsplit(unmatched, ""))
        c(matches, extras)
      })
    ))
  }

  for (model in models_to_run) {
    if (model == "EER") {
      axes <- c("GR", "FR", "PR")
    } else if (model == "Functional Rarity") {
      axes <- c("GR", "GL", "FR", "FL")
    } else {
      axes <- extract_model_axes(model)
    }

    df[[model]] <- apply(df, 1, function(row) {
      parts <- c()
      for (axis in axes) {
        flag_col <- paste0(axis, "_flag")
        val <- if (flag_col %in% colnames(df)) row[[flag_col]] else NA
        parts <- c(parts, paste0(axis, ifelse(is.na(val), "?", val)))
      }
      combo_label <- paste(parts, collapse = "")
      map_est_types(model, combo_label)
    })
  }

  base_order <- c(
    paste0(all_axes, "_raw"),
    paste0(all_axes, "_flag"),
    all_axes
  )
  other_cols <- setdiff(names(df), c(names(df)[1], base_order))
  df <- df[, c(names(df)[1], base_order, other_cols)]

  df <- rename_model_columns(df, models_to_run)
  return(df)
}

